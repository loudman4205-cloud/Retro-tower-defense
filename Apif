-- Shitty X API - Precise Timing Version
-- Self-contained: precise timer (0.1s updates), wait polling (0.03s)
-- Compatible with all recorded macros from the UI script
-- Usage in macro .txt files:
-- local api = loadstring(game:HttpGet('.../rtd/api'))()
-- api:Loadout({...})  -- optional, equips towers
-- api:Map('MapName', {...})  -- optional, logs map/mods
-- api:Start()  -- sets timescale 2x
-- api:Loop(function() ... end)  -- starts precise execution loop

local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local teamwork = RS:WaitForChild("Teawork")
local client = teamwork:WaitForChild("Client")
local shared = teamwork:WaitForChild("Shared")

local bytenet = require(shared.Services.ByteNetworking)
local modifiersmodule = require(client.Services.Game.ModifierController)
local datamodule = require(client.Services.DataSync)

local towers = bytenet.Towers
local mapinfo = RS:WaitForChild("RoundInfo")
local roundresultui = LP.PlayerGui:WaitForChild("GameUI"):WaitForChild("RoundResult")

-- Setup global env (exact match to main UI script for macro compatibility)
local env = getgenv()
env.timer = 0
env.wave = mapinfo:GetAttribute("Wave") or 1
env.map = mapinfo:GetAttribute("Map")
env.modifiers = modifiersmodule.GetModifiers()
env.totalplaced = 0
env.firsttower = 1
env.isroundover = false

-- Precise Timer (0.1s updates)
task.spawn(function()
	local last = os.time()
	while true do
		env.timer = (os.time() - last) * 2
		task.wait(0.1)
	end
end)

-- Auto-track wave/round
mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
	env.wave = mapinfo:GetAttribute("Wave")
end)

roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
	env.isroundover = roundresultui.Visible
end)

-- API object
local api = {}

-- Precise waitTime (0.03s polling for sub-second accuracy)
local function waitTime(t, w)
	while env.wave < w and not env.isroundover do
		task.wait(0.03)
	end
	while env.timer < t and not env.isroundover do
		task.wait(0.03)
	end
	return not env.isroundover
end

function api:Loadout(towersList)
	-- Equip towers (lobby only)
	for slot, towerID in ipairs(towersList or {}) do
		towers.Inventory.EquipTower.invoke({TowerID = towerID, Slot = slot})
		task.wait(0.4)
	end
	print("[API] Loadout applied: " .. #towersList .. " towers")
end

function api:Map(mapName, modsList)
	-- Log/validate map & modifiers (no action needed)
	print("[API] Map: " .. mapName .. " | Mods: " .. #modsList)
end

function api:Start()
	bytenet.Timescale.SetTimescale.send(2)
	print("[API] Started (2x speed)")
end

function api:Ready(t, w)
	if waitTime(t, w) then
		bytenet.ReadyVote.Vote.send(true)
	end
end

function api:Skip(t, w)
	if waitTime(t, w) then
		RS.ByteNetReliable:FireServer(buffer.fromstring("\148\001"))
	end
end

function api:AutoSkip(v, t, w)
	if waitTime(t, w) then
		bytenet.SkipWave.ToggleAutoSkip.send(v)
	end
end

function api:Place(id, pos, t, w)
	if waitTime(t, w) then
		env.totalplaced = env.totalplaced + 1
		towers.PlaceTower.invoke({ TowerID = id, Position = pos, Rotation = 0 })
	end
end

function api:Upgrade(i, t, w)
	if waitTime(t, w) then
		towers.UpgradeTower.invoke(env.firsttower + (i - 1))
	end
end

function api:SetTarget(i, mode, t, w)
	if waitTime(t, w) then
		towers.SetTargetMode.send({
			UID = env.firsttower + (i - 1),
			TargetMode = mode
		})
	end
end

function api:Sell(i, t, w)
	if waitTime(t, w) then
		towers.SellTower.invoke(env.firsttower + (i - 1))
	end
end

function api:PlayAgain()
	while not env.isroundover do task.wait(0.1) end
	env.firsttower = env.totalplaced + 1
	env.totalplaced = 0
	env.timer = 0
	env.wave = 1
	task.wait(1)
	bytenet.RoundResult.VoteForRestart.send(true)
end

function api:Loop(callback)
	-- Infinite loop for macro actions (runs continuously)
	task.spawn(function()
		while true do
			callback()
			task.wait(0.03)  -- Precise loop timing
		end
	end)
	print("[API] Loop started")
end

return api
