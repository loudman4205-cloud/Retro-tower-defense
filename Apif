-- Shitty X API - with explanatory notes only (no code changes)
-- This script handles macro actions for Retro Tower Defense (in-game PlaceId 124069847780670)
-- Lobby-only functions (Loadout/Map) are skipped in-game
-- In-game functions assume the match has started and ByteNet remotes are available

local replicatedstorage = game:GetService("ReplicatedStorage")

-- Loads the custom UI library used for the Shitty X window/tabs/console/logs
-- This is the same library your main UI script uses
local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ovoch228/depthsoimgui/refs/heads/main/library'))()

-- ByteNet networking module - core for all remote calls (place/upgrade/vote/etc.)
-- This is required from the game's Teawork/Shared/Services
local bytenet = require(replicatedstorage:WaitForChild("Teawork"):WaitForChild("Shared"):WaitForChild("Services"):WaitForChild("ByteNetworking"))

-- Main API table returned to macros
local api = {}

-- :Loadout - equips towers in the lobby only
-- What it does: Calls EquipTower.invoke for each tower in the list, slot 1..n
-- What it DOESN'T do: Doesn't work in-game (skips if not lobby PlaceId), doesn't validate tower names, doesn't handle failures/errors
-- Delay: 0.5s between equips to avoid rate-limiting
function api:Loadout(towers: table)
	if game.PlaceId ~= 98936097545088 then return end

	for i = 1, #towers do
		bytenet.Inventory.EquipTower.invoke({["TowerID"] = towers[i], ["Slot"] = i})
		task.wait(0.5)
	end
end

-- :Map - creates a singleplayer match in the lobby only
-- What it does: Fires CreateSingleplayer.invoke with Standard gamemode + given map/modifiers
-- What it DOESN'T do: Doesn't work in-game, doesn't check if map/modifiers are valid, no error handling
function api:Map(map: string, modifiers: table)
	if game.PlaceId ~= 98936097545088 then return end
	
	bytenet.MatchmakingNew.CreateSingleplayer.invoke({["Gamemode"] = "Standard", ["MapID"] = map, ["Modifiers"] = modifiers})
end

-- Only continue loading in-game features if we're in the actual game place
-- What it DOESN'T do: Doesn't load UI or in-game logic in lobby → keeps script lightweight there
if game.PlaceId ~= 124069847780670 then return api end

-- In-game only references (safe because we checked PlaceId above)
local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo

local roundresultui = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.RoundResult

-- Shortcuts for frequently used functions
local ostime = os.time
local taskwait = task.wait
local env = getgenv()

-- Default strat name (used in UI label)
env.StratName = "Strat"

-- Timing & state tracking (updated in :Start)
env.timer = 0 -- seconds
env.lasttime = ostime()
env.waveinfo = 1
env.isroundover = false

env.totalplacedtowers = 0
env.firsttower = 1

-- Flag used by your main UI script to know when to destroy the window (not used here)
env.destroyui = false

-- Creates the Shitty X UI window (same as your main script)
-- Size/position hardcoded, no resize allowed
local window = library:CreateWindow({
    Title = "Shitty X",
    Size = UDim2.new(0, 350, 0, 370),
    Position = UDim2.new(0.5, 0, 0, 70),
    NoResize = false
})

window:Center()

-- "Macro Player" tab (but actually used as main/log tab here)
local logtab = window:CreateTab({
    Name = "Macro Player",
    Visible = true
})

-- Label showing current StratName
local filename = logtab:Label({
    Text = "StratName: " .. env.StratName
})

-- Separate Logs tab
local logstab = window:CreateTab({
    Name = "Logs",
    Visible = true
})

-- Last log message label
local loglabel = logtab:Label({
    Label = "Last Log: Voting"
})

-- Separator + console for full log history
local row = logstab:Row()

logstab:Separator({
	Text = "Logs:"
})

local logs = logstab:Console({
	Text = "",
	ReadOnly = true,
	LineNumbers = false,
	Border = false,
	Fill = true,
	Enabled = true,
	AutoScroll = true,
	RichText = true,
	MaxLines = 200
})

-- Logging function - appends timestamped message + updates top label
-- Uses setthreadidentity(7) - likely to bypass some Roblox thread restrictions
function updatelog(text: string)
	setthreadidentity(7)
	logs:AppendText(DateTime.now():FormatLocalTime("HH:mm:ss", "en-us") .. ":", text)
	loglabel:SetText("Last Log: " .. text)
end

-- Show Macro Player tab by default
window:ShowTab(logtab)
updatelog("Voting")

-- Wait helper - blocks until wave and time are reached
function waitTime(time, wave)
    local startTick = tick()
    local MAX_WAIT = 60

    -- Wait for wave
    while env.waveinfo < wave and not env.isroundover do
        if tick() - startTick > MAX_WAIT then return false end
        task.wait(0.03)
    end

    -- If round already over → bail immediately
    if env.isroundover then return false end

    -- Wait for time (check round end every step)
    while env.timer < time do
        if env.isroundover or tick() - startTick > MAX_WAIT then
            return false
        end
        task.wait(0.03)
    end

    -- Final safety check right before returning
    return not env.isroundover
end

-- :Loop - runs the macro callback forever every ~0.03s
-- What it DOESN'T do: Doesn't throttle based on time/wave — calls func() constantly → can spam remotes if not careful
function api:Loop(func)
	if game.PlaceId ~= 124069847780670 then return end 
	
	while taskwait(0.03) do				
		func()
	end
end

-- :Start - initializes in-game tracking and 3x timescale
-- What it does: Sets timescale to 3×, starts timer at 0, connects wave/round signals
-- Timer multiplier is 3× (not 2× like some other versions)
-- What it DOESN'T do: Doesn't handle timescale failures, no error logging
function api:Start()
	bytenet.Timescale.SetTimescale.send(3)

	env.waveinfo = mapinfo:GetAttribute("Wave") or 1
	env.timer = 0
	
	mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
		env.waveinfo = mapinfo:GetAttribute("Wave")
	end)

	roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
		isroundover = roundresultui.Visible
	end)
	
	updatelog("Game Started")
		
	task.spawn(function()
		lasttime = ostime()
		while env.lasttime do
			env.timer = (ostime() - env.lasttime) * 3
			--print(string.format("Timer: %.1f | Wave: %d", timer, waveinfo))
			
			taskwait(0.25)
		end
	end)
end

-- :Difficulty - votes difficulty, waits for confirmation, resets timer/wave
-- Improvements:
--   - Uses pcall to prevent crashes if vote remote fails
--   - Adds timeout to the wait loop (prevents hanging forever if attribute never updates)
--   - Logs success/failure + actual difficulty value after confirmation
--   - Resets timer only after confirmation (safer)
-- What it still DOESN'T do:
--   - Can't force a vote if server ignores it
--   - Assumes "Difficulty" attribute is the correct one to check

function api:Difficulty(diff: string)
    updatelog(`Voting difficulty: {diff}`)

    local voteSuccess, voteErr = pcall(function()
        bytenet.DifficultyVote.Vote.send(diff)
    end)

    if not voteSuccess then
        updatelog(`Difficulty vote failed: {tostring(voteErr)}`)
        return false
    end

    updatelog(`Vote sent for {diff} - waiting for confirmation`)

    local start = tick()
    local MAX_WAIT = 15  -- seconds timeout

    while #mapinfo:GetAttribute("Difficulty") == 0 do
        if tick() - start > MAX_WAIT then
            updatelog("Difficulty confirmation timeout - assuming failed")
            return false
        end
        task.wait(0.05)
    end

    local confirmedDiff = mapinfo:GetAttribute("Difficulty")
    updatelog(`Difficulty confirmed: {confirmedDiff}`)

    -- Only reset timer/wave after confirmation
    env.lasttime = ostime()
    env.timer = 0
    env.waveinfo = 1

    task.wait(0.1)
    return true
end

-- :Ready - sends ready vote when time/wave reached
-- Improvements:
--   - Uses pcall to prevent crash if remote fails
--   - Adds log if vote was sent successfully
--   - Returns true/false so macros can react (e.g. retry or skip)
--   - Small delay after vote to let server process (optional but helps stability)
-- What it still DOESN'T do:
--   - Doesn't wait for server confirmation (no "ready" attribute to check)
--   - Doesn't retry if vote fails

function api:Ready(time: number, wave: number)
    if not waitTime(time, wave) then
        updatelog("Ready skipped - round ended or timeout")
        return false
    end

    local success, err = pcall(function()
        bytenet.ReadyVote.Vote.send(true)
    end)

    if success then
        updatelog("Sent ready vote")
        task.wait(0.15)  -- small buffer for server ack
        return true
    else
        updatelog(`Ready vote failed: {tostring(err)}`)
        return false
    end
end

-- :Skip - fires wave skip remote
function api:Skip(time: number, wave: number)
	if waitTime(time, wave) then updatelog(`Skipping Wave {wave}`) replicatedstorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\148\001")) end
end

-- :AutoSkip - toggles auto-skip
-- enable should be boolean/true/false, but typed as number (likely typo in original)
function api:AutoSkip(enable: number, time: number, wave: number)
	if waitTime(time, wave) then updatelog(`AutoSkip set to {tostring(enable)}`) bytenet.SkipWave.ToggleAutoSkip.send(enable) end
end

-- :Place - places a tower at exact time/wave
-- Updates totalplacedtowers counter
function api:Place(tower: string, position: Vector3, time: number, wave: number)
	if waitTime(time, wave) then	
		env.totalplacedtowers = env.totalplacedtowers + 1
		
		updatelog(`Placed Tower {tower}`)
		towers.PlaceTower.invoke({["Position"] = position, ["Rotation"] = 0, ["TowerID"] = tower})
	end
end

-- :Upgrade - upgrades tower by relative index (1 = first placed, etc.)
-- Uses firsttower offset (usually 1 unless restarted)
function api:Upgrade(tower: number, time: number, wave: number)
	if waitTime(time, wave) then
		updatelog(`Upgraded Tower {tower}`)
		
		local realindex = firsttower + (tower - 1)
		towers.UpgradeTower.invoke(realindex)
	end
end

-- :SetTarget - changes targeting mode (First/Last/Strongest/etc.)
function api:SetTarget(tower: number, target: string, time: number, wave: number)
	if waitTime(time, wave) then
		updatelog(`Changed Tower {tower} Target to {target} `)
	
		local realindex = firsttower + (tower - 1)
		towers.SetTargetMode.send({["UID"] = (realindex), ["TargetMode"] = target})
	end
end

-- :Sell - sells tower by relative index
function api:Sell(tower: number, time: number, wave: number)
	if waitTime(time, wave) then
		updatelog(`Sold Tower {tower}`) 
		
		local realindex = firsttower + (tower - 1)
		towers.SellTower.invoke(realindex)
	end
end

-- Improved api:PlayAgain - waits for vote confirmation + timeout safety
-- What it does now:
--   - Times out initial round-end wait after 60s (prevents hang if round stuck)
--   - After voting: waits for RoundResult UI to hide (vote accepted + restart starting)
--   - Confirms restart by checking new wave starts (mapinfo Wave resets to 1 or similar)
--   - Resets state only after full confirmation
--   - Uses pcall on vote to avoid crashes
-- What it still DOESN'T do:
--   - Doesn't force-restart if vote fails (relies on server vote system)
--   - Assumes RoundResult hides on successful restart (game-specific)

function api:PlayAgain()
    -- Phase 1: Wait for round end with timeout
    local startWait = tick()
    while not env.isroundover and tick() - startWait < 60 do
        task.wait(0.1)
    end
    if not env.isroundover then
        updatelog("PlayAgain timeout - round didn't end")
        return false  -- Failed, don't reset state
    end
    updatelog("Round ended - voting restart")

    -- Phase 2: Vote with safety
    local voteSuccess = pcall(bytenet.RoundResult.VoteForRestart.send, true)
    if not voteSuccess then
        updatelog("Vote failed - retry manually")
        return false
    end
    updatelog("Voted for restart")

    -- Phase 3: Wait for confirmation (UI hides + new round starts)
    startWait = tick()
    while roundresultui.Visible and tick() - startWait < 30 do  -- Wait for UI to hide
        task.wait(0.2)
    end
    if roundresultui.Visible then
        updatelog("Restart UI didn't hide - may have failed")
        return false
    end

    -- Wait a bit more for new round init (wave resets)
    task.wait(2)
    startWait = tick()
    while (mapinfo:GetAttribute("Wave") or 0) <= 1 and tick() - startWait < 20 do
        task.wait(0.5)
    end

    -- Confirmed: reset state
    env.firsttower = env.totalplacedtowers + 1
    env.lasttime = os.time()
    env.timer = 0
    env.waveinfo = 1

    updatelog("Restart confirmed - state reset")
    return true  -- Success
end
